### START OF CODE GENERATED BY Argbash v2.5.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='hVmcjiqQpPsSC'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_verbose=yes
_arg_autodetect_machine=yes
_arg_compiler=
_arg_make_j=
_arg_isa=
_arg_only_qphix=no
_arg_qphix_branch="devel"
_arg_precision="double"
_arg_precision_inner="single"
_arg_soalen=
_arg_soalen_inner=
_arg_chroma_branch="devel"

print_help ()
{
  printf "%s\n" "Installs Chroma with dependencies from scratch.

This is a script to install Chroma, QPhiX, QDP++, QMP, and their
dependencies on the following HPC systems:

+--------------+----------------------------+------------------------------+
| Name         | Architecture               | Location                     |
+==============+============================+==============================+
| Hazel Hen    | Haswell (AVX2)             | Stuttgart, Germany           |
+--------------+----------------------------+------------------------------+
| JURECA       | Haswell (AVX2)             | JÃ¼lich, Germany              |
+--------------+----------------------------+------------------------------+
| Marconi A2   | Knights Landing (AVX512)   | Casalecchio di Reno, Italy   |
+--------------+----------------------------+------------------------------+

The script will automatically find out which computer you run it on. If
this check fails, the script need to be fixed.

After this script ran though, you will have the following directories::

    BASE/build-icc/chroma
    BASE/build-icc/libxml2
    BASE/build-icc/qdpxx
    BASE/build-icc/qmp
    BASE/build-icc/qphix

    BASE/local-icc/bin
    BASE/local-icc/include
    BASE/local-icc/lib
    BASE/local-icc/share

    BASE/sources/chroma
    BASE/sources/libxml2
    BASE/sources/qdpxx
    BASE/sources/qmp
    BASE/sources/qphix
"
  printf 'Usage: %s [-h|--help] [-V|--(no-)verbose] [-m|--(no-)autodetect-machine] [-c|--compiler <arg>] [-j|--make-j <arg>] [-i|--isa <arg>] [-q|--(no-)only-qphix] [-Q|--qphix-branch <arg>] [-p|--precision <arg>] [-P|--precision-inner <arg>] [-s|--soalen <arg>] [-S|--soalen-inner <arg>] [-C|--chroma-branch <arg>] <basedir>\n' "$0"
  printf "\t%s\n" "<basedir>: Base path"
  printf "\t%s\n" "-h,--help: Prints help"
  printf "\t%s\n" "-V,--verbose,--no-verbose: Print Bash commands executed (yes by default)"
  printf "\t%s\n" "-m,--autodetect-machine,--no-autodetect-machine: Automatically figure out which machine we are on (yes by default)"
  printf "\t%s\n" "-c,--compiler: Compiler family to use, defaults to best on given machine (no default)"
  printf "\t%s\n" "-j,--make-j: Maximum number of parallel processes used by make (no default)"
  printf "\t%s\n" "-i,--isa: Manual instruction set architecture (ISA), usually automatically set (no default)"
  printf "\t%s\n" "-q,--only-qphix,--no-only-qphix: Only compile QPhiX, not Chroma (no by default)"
  printf "\t%s\n" "-Q,--qphix-branch: QPhiX git branch (default: '"devel"')"
  printf "\t%s\n" "-p,--precision: Precision of solver, can be "double", "float" (default: '"double"')"
  printf "\t%s\n" "-P,--precision-inner: Precision of inner solver, can be "double", "float" or "half" (default: '"single"')"
  printf "\t%s\n" "-s,--soalen: Structure of array (SoA) length (no default)"
  printf "\t%s\n" "-S,--soalen-inner: Structure of array (SoA) length for inner solver (no default)"
  printf "\t%s\n" "-C,--chroma-branch: Chroma git branch (default: '"devel"')"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -V|--no-verbose|--verbose)
        _arg_verbose="on"
        test "${1:0:5}" = "--no-" && _arg_verbose="off"
        ;;
      -V*)
        _arg_verbose="on"
        _next="${_key##-V}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-V" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -m|--no-autodetect-machine|--autodetect-machine)
        _arg_autodetect_machine="on"
        test "${1:0:5}" = "--no-" && _arg_autodetect_machine="off"
        ;;
      -m*)
        _arg_autodetect_machine="on"
        _next="${_key##-m}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-m" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -c|--compiler)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_compiler="$2"
        shift
        ;;
      --compiler=*)
        _arg_compiler="${_key##--compiler=}"
        ;;
      -c*)
        _arg_compiler="${_key##-c}"
        ;;
      -j|--make-j)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_make_j="$2"
        shift
        ;;
      --make-j=*)
        _arg_make_j="${_key##--make-j=}"
        ;;
      -j*)
        _arg_make_j="${_key##-j}"
        ;;
      -i|--isa)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_isa="$2"
        shift
        ;;
      --isa=*)
        _arg_isa="${_key##--isa=}"
        ;;
      -i*)
        _arg_isa="${_key##-i}"
        ;;
      -q|--no-only-qphix|--only-qphix)
        _arg_only_qphix="on"
        test "${1:0:5}" = "--no-" && _arg_only_qphix="off"
        ;;
      -q*)
        _arg_only_qphix="on"
        _next="${_key##-q}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-q" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -Q|--qphix-branch)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_qphix_branch="$2"
        shift
        ;;
      --qphix-branch=*)
        _arg_qphix_branch="${_key##--qphix-branch=}"
        ;;
      -Q*)
        _arg_qphix_branch="${_key##-Q}"
        ;;
      -p|--precision)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_precision="$2"
        shift
        ;;
      --precision=*)
        _arg_precision="${_key##--precision=}"
        ;;
      -p*)
        _arg_precision="${_key##-p}"
        ;;
      -P|--precision-inner)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_precision_inner="$2"
        shift
        ;;
      --precision-inner=*)
        _arg_precision_inner="${_key##--precision-inner=}"
        ;;
      -P*)
        _arg_precision_inner="${_key##-P}"
        ;;
      -s|--soalen)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_soalen="$2"
        shift
        ;;
      --soalen=*)
        _arg_soalen="${_key##--soalen=}"
        ;;
      -s*)
        _arg_soalen="${_key##-s}"
        ;;
      -S|--soalen-inner)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_soalen_inner="$2"
        shift
        ;;
      --soalen-inner=*)
        _arg_soalen_inner="${_key##--soalen-inner=}"
        ;;
      -S*)
        _arg_soalen_inner="${_key##-S}"
        ;;
      -C|--chroma-branch)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_chroma_branch="$2"
        shift
        ;;
      --chroma-branch=*)
        _arg_chroma_branch="${_key##--chroma-branch=}"
        ;;
      -C*)
        _arg_chroma_branch="${_key##-C}"
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'basedir'"
  test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
  test ${#_positionals[@]} -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_basedir' )

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
# ] <-- needed because of Argbash
